/*
	作用：使用户能够自定义数据类型(结构体名)并在其中存储不同的数据类型(成员列表)。
	本质：一些类型集合组成了一个新的自定义的类型。

	定义语法：
		struct 结构体名
		{
		  结构体成员列表
		};
	 eg.struct Student
		{ string name;
		  int age;
		  int score;
		};

	创建语法( 与创建变量的语法相比多了一个前缀struct,但是这里的struct可以省略 )：
		1. struct 数据类型(结构体名) 变量名;
		   变量名.成员1 = 成员1值;
		   变量名.成员2 = 成员2值;
		   ……

		2. struct 数据类型(结构体名) 变量名 = { 成员1值 , 成员2值 ……};

		3. 当需要对同一结构体创建多个变量时，可以创建成结构体数组，语法为：
					struct 数据类型(结构体名) 数组名[长度] =
					{
						{"张三", 18, 68},
						{"李四", 81, 98},
						……
					};
					后期如何修改里面的某个值？ -- 结合数组索引和成员访问：数组名[1].name = "赵六"
																		  数组名[0].score = 88

	案例：
		1. 如何遍历结构体数组。
		2. 如何创建结构体指针，比较‘利用指针来访问结构体的成员’与之前访问结构体成员的不同。
		3. 如何将结构体作为参数传入函数，并比较两种传入方式的不同。
		   此处的案例是将学生结构体传入到函数中，打印学生身上的所有信息。

	总结：
		1. 定义结构体时struct关键字不可省略，
		   创建结构体时struct关键字可以省略。
		2. 定义结构体时成员之间用";"隔开，而且最后一个成员后面也要加上";"；
		   创建结构体时成员之间用","隔开。
		3. 利用操作符"."可以访问结构体的成员；
		   利用操作符"->"可以通过结构体指针访问结构体的成员。
		4. 结构体的成员可以是另外一个结构体。(结构体嵌套)
		5. 将结构体作为参数传入函数与之前将变量作为参数传入函数是一样的，只是形参的数据类型要与结构体对应而已。并
		且同样具有值传递和地址传递两种方式。
		   值传递：无论数据有多大，都会复制一份传入函数，因此消耗内存，而且影响效率；
		   地址传递：不管数据有多大，指针只占四个字节的内存，通过指针也可以完成相关的访问操作。
		6. 当想要防止误操作时，可以在声明形参时加上 const 关键字，将相关数据设置为只读。
*/
#include <iostream>
using namespace std;

struct Student
{
	string name;
	int age;
	int score;
};

int main()
{
	struct Student stuArr[3] = {
		{"张三", 18, 68},
		{"李四", 81, 98},
		{"赵六", 21, 78},

	};
	// 如何遍历结构体数组。
	for (int i = 0; i < 3; i++)
	{
		cout << "姓名：" << stuArr[i].name
			<< "年龄：" << stuArr[i].age
			<< "分数：" << stuArr[i].score << endl;
	}

	// 如何创建结构体指针，比较‘利用指针来访问结构体的成员’与之前访问结构体成员的不同。
	struct Student stu = { "王五",41,14 };
	struct Student* p = &stu; // 注意指针类型，原则是" = "两边要有相同的数据类型。
	p->name = "王五五";       // 利用操作符"->"可以通过结构体指针访问结构体的成员
	cout << "姓名：" << p->name << endl;

	system("pause");
	return 0;
}